// author of
isa(?s, Author) and belong_to(?s, ?o) => author(?s, ?o);

// name
name(?a, ?b) => name(?a, ?b);

// ??
at_time(?e, ?f) and subject(?e, ?sub1) and subject(?f, ?sub2) and isa(?f, Die) and name(?sub1, ?nn) => time_property(?sub1, ?t) and die_at(?sub2, ?t);

// same name
subject(?e, ?s) and subject(?e, ?t) and name(?s, ?n) => name(?t, ?n);

// influenced by
isa(?e, Influence) and subject(?e, ?s) and object(?e, ?o) => influence(?s, ?o);

// have children
isa(?e, Have) and subject(?e, ?s) and object(?e, ?o) and isa(?o, Child) => child(?s, ?o);

// born in
location(?e, ?q) and isa(?e, Bear) and object(?e, ?o) => born_in(?o, ?q);

// born at (1)
born(?a, ?b) => born_at(?a, ?b);

// born at (2)
at_time(?e, ?q) and isa(?e, Bear) and object(?e, ?o) => born_at(?o, ?q);

// die in
location(?e, ?q) and isa(?e, Die) and subject(?e, ?s) => die_in(?s, ?q);

// die at
die(?a, ?b) => die_at(?a, ?b);

// daughter
isa(?child, Daughter) and belong_to(?child, ?parent) => child(?parent, ?child);

// child
isa(?child, Child) and belong_to(?child, ?parent) => child(?parent, ?child);

// unimportant predicates
isa(?a, ?b) => true();
subject(?a, ?b) => true();
object(?a, ?b) => true();
tense(?a, ?b) => true();
reference(?a) => true();
let(?a, ?b) => true();
aggregate(?a, ?b) => true();
manner(?o, ?q) and isa(?o, Child) => true();
